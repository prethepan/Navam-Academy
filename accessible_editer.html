<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Accessible Video/Audio Editor (Keyboard + Screen Reader)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  body { margin: 0; padding: 1rem; }
  header { margin-bottom: 1rem; }
  .row { display: flex; gap: 1rem; flex-wrap: wrap; align-items: center; }
  .panel { border: 1px solid #ccc; border-radius: .5rem; padding: .75rem; }
  video, audio { width: 100%; max-height: 50vh; background: #000; }
  .controls button, .controls input, .controls select, .controls label { margin: .25rem .25rem .25rem 0; }
  .segments { max-height: 30vh; overflow:auto; }
  .segments table { border-collapse: collapse; width:100%; }
  .segments th, .segments td { border: 1px solid #ddd; padding: .5rem; text-align:left; }
  .kbd { border: 1px solid #aaa; border-radius: .25rem; padding: .1rem .3rem; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .sr-only { position:absolute; left:-10000px; width:1px; height:1px; overflow:hidden; }
  .status { margin-top:.5rem; }
  .file-pill { display:inline-block; border:1px solid #ddd; border-radius:999px; padding:.1rem .5rem; margin:.1rem .25rem; }
</style>
</head>
<body>
<header>
  <h1>Accessible Video/Audio Editor</h1>
  <p id="intro">
    Keyboard: <span class="kbd">Space</span> Play/Pause, 
    <span class="kbd">←</span>/<span class="kbd">→</span> Seek, 
    <span class="kbd">Shift+1</span>/<span class="kbd">Shift+2</span>/<span class="kbd">Shift+3</span>/<span class="kbd">Shift+4</span> set seek step (1s / 5s / 1m / 10m).
    Use buttons or shortcuts to mark <span class="kbd">I</span>/<span class="kbd">O</span>, split <span class="kbd">S</span>, and export <span class="kbd">E</span>.
  </p>
</header>

<div class="row">
  <section class="panel" aria-labelledby="mediaPanelHeading" style="flex:2 1 420px;">
    <h2 id="mediaPanelHeading">Player</h2>
    <video id="player" aria-label="Preview player" tabindex="0"></video>
    <div class="controls" role="group" aria-label="Transport and edit controls">
      <button id="btnOpen" type="button">Add media…</button>
      <button id="btnAddBgm" type="button">Add background music…</button>
      <button id="btnPlay" type="button" aria-pressed="false">Play (Space)</button>
      <label>Seek step: <output id="seekStepLabel">1s</output></label>
      <button id="btnSetIn" type="button" title="Mark In (I)">Set In</button>
      <button id="btnSetOut" type="button" title="Mark Out (O)">Set Out</button>
      <button id="btnSplit" type="button" title="Split at Playhead (S)">Split</button>
      <button id="btnExport" type="button" title="Export (E)">Export</button>
    </div>
    <div aria-live="polite" aria-atomic="true" id="live" class="status"></div>
    <input id="fileInput" type="file" accept="video/*,audio/*" multiple class="sr-only" aria-hidden="true" />
    <input id="bgmInput" type="file" accept="audio/*" class="sr-only" aria-hidden="true" />
  </section>

  <section class="panel" aria-labelledby="timelineHeading" style="flex:1 1 320px;">
    <h2 id="timelineHeading">Timeline Segments</h2>
    <div class="segments" role="region" aria-label="Segments list">
      <table aria-describedby="segHelp">
        <thead>
          <tr><th>Sel</th><th>#</th><th>Start</th><th>End</th><th>Dur</th><th>Source</th></tr>
        </thead>
        <tbody id="segBody"></tbody>
      </table>
      <p id="segHelp">Use the checkboxes to select segments for merging. Split creates two segments around the playhead.</p>
    </div>
    <div>
      <p>Loaded files:</p>
      <div id="fileList" aria-live="polite"></div>
      <p><strong>BGM:</strong> <span id="bgmName">None</span> (loops/trims up to 10 minutes)</p>
    </div>
  </section>
</div>

<section class="panel" aria-labelledby="shortcutsHeading">
  <h2 id="shortcutsHeading">Keyboard shortcuts</h2>
  <ul>
    <li><span class="kbd">Space</span>: Play/Pause</li>
    <li><span class="kbd">←</span>/<span class="kbd">→</span>: Seek backward/forward by current step</li>
    <li><span class="kbd">Shift+1</span> 1s, <span class="kbd">Shift+2</span> 5s, <span class="kbd">Shift+3</span> 60s, <span class="kbd">Shift+4</span> 600s (10 min)</li>
    <li><span class="kbd">I</span>/<span class="kbd">O</span>: Set In/Out at current time</li>
    <li><span class="kbd">S</span>: Split segment at playhead</li>
    <li><span class="kbd">E</span>: Export (concat + optional BGM mix)</li>
  </ul>
</section>

<!-- ffmpeg.wasm (core + helpers) -->
<script type="module">
/* ======= State ======= */
const live = document.getElementById('live');
const player = document.getElementById('player');
const fileInput = document.getElementById('fileInput');
const bgmInput = document.getElementById('bgmInput');
const fileList = document.getElementById('fileList');
const segBody = document.getElementById('segBody');
const seekStepLabel = document.getElementById('seekStepLabel');
const bgmName = document.getElementById('bgmName');
const btnPlay = document.getElementById('btnPlay');

let seekStep = 1; // seconds
let files = [];   // [{name, arrayBuffer, type, url}]
let bgm = null;   // {name, arrayBuffer, type}
let segments = []; // [{id, srcIndex, start, end}] in seconds, inclusive start, exclusive end
let currentSegmentIndex = -1;

// Lazy load ffmpeg when exporting
let ffmpeg = null;
let FFmpeg = null;

/* ======= Helpers ======= */
function announce(msg) {
  live.textContent = msg;
  console.log('[announce]', msg);
}

function fmtTime(t) {
  if (!Number.isFinite(t)) return '—';
  const sign = t < 0 ? '-' : '';
  t = Math.max(0, Math.floor(Math.abs(t)));
  const h = Math.floor(t/3600);
  const m = Math.floor((t%3600)/60);
  const s = t%60;
  return sign + (h?`${h}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`:`${m}:${s.toString().padStart(2,'0')}`);
}

function refreshFileList() {
  fileList.innerHTML = '';
  files.forEach((f, i) => {
    const span = document.createElement('span');
    span.className = 'file-pill';
    span.textContent = `#${i+1} ${f.name}`;
    fileList.appendChild(span);
  });
}

function refreshSegments() {
  segBody.innerHTML = '';
  segments.forEach((seg, i) => {
    const tr = document.createElement('tr');
    const tdSel = document.createElement('td');
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.setAttribute('aria-label', `Select segment ${i+1}`);
    cb.dataset.index = i;
    tdSel.appendChild(cb);
    const tdIdx = document.createElement('td'); tdIdx.textContent = i+1;
    const tdStart = document.createElement('td'); tdStart.textContent = fmtTime(seg.start);
    const tdEnd = document.createElement('td'); tdEnd.textContent = fmtTime(seg.end);
    const tdDur = document.createElement('td'); tdDur.textContent = fmtTime(seg.end - seg.start);
    const tdSrc = document.createElement('td'); tdSrc.textContent = files[seg.srcIndex]?.name || '—';
    tr.append(tdSel, tdIdx, tdStart, tdEnd, tdDur, tdSrc);
    segBody.appendChild(tr);
  });
}

/* ======= Media Loading ======= */
async function pickFiles() {
  fileInput.value = '';
  fileInput.click();
}
fileInput.addEventListener('change', async (e) => {
  const picked = Array.from(e.target.files || []);
  for (const file of picked) {
    const buf = await file.arrayBuffer();
    const url = URL.createObjectURL(new Blob([buf], { type: file.type || 'application/octet-stream' }));
    files.push({ name: file.name, arrayBuffer: buf, type: file.type, url });
    // default: create a full-length segment for each new file (duration estimated later)
    segments.push({ id: crypto.randomUUID(), srcIndex: files.length-1, start: 0, end: Infinity });
  }
  refreshFileList();
  refreshSegments();
  // Load first file to player if none loaded
  if (!player.src && files.length) {
    loadSegment(0);
  }
  announce(`${picked.length} file(s) added.`);
});

document.getElementById('btnOpen').addEventListener('click', pickFiles);

document.getElementById('btnAddBgm').addEventListener('click', () => {
  bgmInput.value = '';
  bgmInput.click();
});
bgmInput.addEventListener('change', async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;
  bgm = { name: file.name, arrayBuffer: await file.arrayBuffer(), type: file.type || 'audio/mpeg' };
  bgmName.textContent = `${bgm.name} (max 10 min)`;
  announce(`Background music ${bgm.name} added.`);
});

/* ======= Playback & Navigation ======= */
function loadSegment(index) {
  const seg = segments[index];
  if (!seg) return;
  currentSegmentIndex = index;
  const src = files[seg.srcIndex];
  if (!src) return;
  player.src = src.url;
  player.load();
  player.currentTime = seg.start || 0;
  // If we used Infinity as placeholder, trim end to real duration after metadata loads
  player.onloadedmetadata = () => {
    if (!Number.isFinite(seg.end) || seg.end > player.duration) seg.end = player.duration;
    refreshSegments();
    announce(`Loaded segment ${index+1} from ${src.name}, ${fmtTime(seg.start)} to ${fmtTime(seg.end)}.`);
  };
}

function togglePlay() {
  if (player.paused) {
    player.play();
    btnPlay.setAttribute('aria-pressed','true');
    btnPlay.textContent = 'Pause (Space)';
    announce('Playing.');
  } else {
    player.pause();
    btnPlay.setAttribute('aria-pressed','false');
    btnPlay.textContent = 'Play (Space)';
    announce('Paused.');
  }
}

btnPlay.addEventListener('click', togglePlay);
player.addEventListener('ended', () => {
  // loop within segment
  const seg = segments[currentSegmentIndex];
  if (seg && Number.isFinite(seg.end) && player.currentTime >= seg.end) {
    player.currentTime = seg.start;
    player.pause();
    btnPlay.setAttribute('aria-pressed','false');
    btnPlay.textContent = 'Play (Space)';
  }
});
player.addEventListener('timeupdate', () => {
  const seg = segments[currentSegmentIndex];
  if (seg && Number.isFinite(seg.end) && player.currentTime >= seg.end) {
    player.pause();
    player.currentTime = seg.start;
    btnPlay.setAttribute('aria-pressed','false');
    btnPlay.textContent = 'Play (Space)';
  }
});

/* ======= Keyboard ======= */
function setSeekStep(seconds) {
  seekStep = seconds;
  seekStepLabel.textContent = seconds>=60 ? `${Math.round(seconds/60)}m` : `${seconds}s`;
  announce(`Seek step set to ${seekStepLabel.textContent}.`);
}

document.addEventListener('keydown', (e) => {
  // Avoid interfering with typing in inputs
  const tag = (e.target && (e.target.tagName || '')).toLowerCase();
  const editable = (e.target && (e.target.isContentEditable));
  if (tag === 'input' || tag === 'textarea' || editable) return;

  if (e.code === 'Space') {
    e.preventDefault();
    togglePlay();
  } else if (e.code === 'ArrowLeft') {
    e.preventDefault();
    player.currentTime = Math.max(0, player.currentTime - seekStep);
    announce(`Seek backward ${seekStepLabel.textContent}. Now at ${fmtTime(player.currentTime)}.`);
  } else if (e.code === 'ArrowRight') {
    e.preventDefault();
    player.currentTime = Math.min(player.duration || Infinity, player.currentTime + seekStep);
    announce(`Seek forward ${seekStepLabel.textContent}. Now at ${fmtTime(player.currentTime)}.`);
  } else if (e.shiftKey && e.key === '1') {
    e.preventDefault(); setSeekStep(1);
  } else if (e.shiftKey && e.key === '2') {
    e.preventDefault(); setSeekStep(5);
  } else if (e.shiftKey && e.key === '3') {
    e.preventDefault(); setSeekStep(60);
  } else if (e.shiftKey && e.key === '4') {
    e.preventDefault(); setSeekStep(600); // 10 minutes
  } else if (!e.shiftKey && (e.key === 'i' || e.key === 'I')) {
    e.preventDefault(); setIn();
  } else if (!e.shiftKey && (e.key === 'o' || e.key === 'O')) {
    e.preventDefault(); setOut();
  } else if (!e.shiftKey && (e.key === 's' || e.key === 'S')) {
    e.preventDefault(); splitAtPlayhead();
  } else if (!e.shiftKey && (e.key === 'e' || e.key === 'E')) {
    e.preventDefault(); exportProject();
  }
});

/* ======= Mark In/Out, Split, Merge ======= */
function getCurrentSeg() { return segments[currentSegmentIndex] || null; }

function setIn() {
  const seg = getCurrentSeg(); if (!seg) return;
  const t = Math.min(player.currentTime, seg.end - 0.05);
  seg.start = Math.max(0, t);
  if (player.currentTime < seg.start) player.currentTime = seg.start;
  refreshSegments();
  announce(`In set to ${fmtTime(seg.start)}.`);
}

function setOut() {
  const seg = getCurrentSeg(); if (!seg) return;
  const t = Math.max(player.currentTime, seg.start + 0.05);
  seg.end = Math.min(player.duration || seg.end, t);
  refreshSegments();
  announce(`Out set to ${fmtTime(seg.end)}.`);
}

function splitAtPlayhead() {
  const seg = getCurrentSeg(); if (!seg) return;
  const t = player.currentTime;
  if (t <= seg.start + 0.05 || t >= seg.end - 0.05) {
    announce('Playhead must be inside the segment to split.'); return;
  }
  const before = { id: crypto.randomUUID(), srcIndex: seg.srcIndex, start: seg.start, end: t };
  const after  = { id: crypto.randomUUID(), srcIndex: seg.srcIndex, start: t, end: seg.end };
  segments.splice(currentSegmentIndex, 1, before, after);
  refreshSegments();
  loadSegment(currentSegmentIndex); // load "before"
  announce(`Segment split at ${fmtTime(t)}.`);
}

/* ======= Export with ffmpeg.wasm ======= */
async function ensureFfmpeg() {
  if (ffmpeg) return;
  // Import dynamically to avoid loading on page open
  const mod = await import('https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.9/dist/ffmpeg.min.js');
  const fetchMod = await import('https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/umd/index.min.js');
  FFmpeg = mod.createFFmpeg;
  const { fetchFile } = fetchMod;
  ffmpeg = FFmpeg({ log: true });
  // expose helper
  window._fetchFile = fetchFile;
  await ffmpeg.load();
}

async function exportProject() {
  try {
    await ensureFfmpeg();
  } catch (e) {
    announce('Failed to load ffmpeg. Check your network and try again.');
    console.error(e);
    return;
  }
  announce('Preparing export… this runs locally and can take time.');

  // Collect selected segments; if none selected, export all
  const selected = Array.from(segBody.querySelectorAll('input[type=checkbox]'))
    .map((cb, i)=>({i, checked: cb.checked}))
    .filter(o=>o.checked)
    .map(o=>segments[o.i]);

  const toExport = selected.length ? selected : segments.slice();

  if (!toExport.length) { announce('No segments to export.'); return; }

  // Write inputs and build per-segment trim commands
  const listEntries = [];
  const uniqueSrcIndexes = [...new Set(toExport.map(s=>s.srcIndex))];

  // Write each unique source file once
  for (const idx of uniqueSrcIndexes) {
    const src = files[idx];
    if (!src) { announce('A segment references a missing source file.'); return; }
    const vname = `in_${idx}`;
    await ffmpeg.FS('writeFile', vname, new Uint8Array(src.arrayBuffer));
  }

  // Build filter_complex concat with trims (re-encode for safety)
  // We’ll create labeled streams: v0,a0 for first segment, then concat
  let filterParts = [];
  let vLabels = [];
  let aLabels = [];
  let segCounter = 0;

  for (const seg of toExport) {
    const labelV = `v${segCounter}`;
    const labelA = `a${segCounter}`;
    // Use trim on decoded streams (setpts, asetpts reset timestamps)
    // Note: using start/end in seconds
    filterParts.push(
      `[${seg.srcIndex}:v]trim=start=${seg.start}:end=${seg.end},setpts=PTS-STARTPTS[${labelV}]`,
      `[${seg.srcIndex}:a]atrim=start=${seg.start}:end=${seg.end},asetpts=PTS-STARTPTS[${labelA}]`
    );
    vLabels.push(`[${labelV}]`);
    aLabels.push(`[${labelA}]`);
    segCounter++;
  }

  // Concat all segments (N x video+audio)
  filterParts.push(`${vLabels.join('')}${aLabels.join('')}concat=n=${toExport.length}:v=1:a=1[vcat][acat]`);

  // Optional: mix background music (loop/trim to 10 min max)
  let mapVideo = '[vcat]';
  let mapAudio = '[acat]';
  let outFile = 'output.mp4';

  if (bgm) {
    // Write bgm
    await ffmpeg.FS('writeFile', 'bgm', new Uint8Array(bgm.arrayBuffer));

    // We’ll extend filter graph: bring bgm in, aformat, loop/atrim to 600s,
    // then mix with exported audio (duck bgm to -18dB).
    // Note: amix normalizes length via shortest=1; we also trim bgm to 600s.
    filterParts.push(
      `[1:a]aloop=loop=-1:size=1152,asetpts=N/SR/TB,atrim=0:600,volume=0.15[bgmquiet]`,
      `[acat][bgmquiet]amix=inputs=2:duration=first:dropout_transition=3[mixed]`
    );
    mapAudio = '[mixed]';
  }

  // Build args
  // Input order: all unique sources (as binary), then optionally bgm as the last input
  const args = [];
  // push -i for each source
  for (const idx of uniqueSrcIndexes) {
    args.push('-i', `in_${idx}`);
  }
  if (bgm) {
    args.push('-i', 'bgm');
  }
  args.push(
    '-filter_complex', filterParts.join(';'),
    '-map', mapVideo,
    '-map', mapAudio,
    '-c:v', 'libx264', '-preset', 'veryfast', '-crf', '23',
    '-c:a', 'aac', '-b:a', '192k',
    '-movflags', '+faststart',
    outFile
  );

  try {
    const result = await ffmpeg.run(...args);
    console.log('ffmpeg log:', result);
    const data = ffmpeg.FS('readFile', outFile);
    const blob = new Blob([data.buffer], { type: 'video/mp4' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = outFile;
    a.click();
    announce('Export complete. Your file download should start now.');
  } catch (err) {
    console.error(err);
    announce('Export failed. Try fewer/shorter segments, or check console for details.');
  }
}

/* ======= Button bindings ======= */
document.getElementById('btnSetIn').addEventListener('click', setIn);
document.getElementById('btnSetOut').addEventListener('click', setOut);
document.getElementById('btnSplit').addEventListener('click', splitAtPlayhead);
document.getElementById('btnExport').addEventListener('click', exportProject);

/* ======= Click a row to load its segment ======= */
segBody.addEventListener('click', (e) => {
  const row = e.target.closest('tr');
  if (!row) return;
  const index = Array.from(segBody.children).indexOf(row);
  if (index >= 0) {
    loadSegment(index);
    player.focus();
  }
});

/* ======= Initial UI ======= */
setSeekStep(1);
announce('Ready. Press "Add media…" to load files, then Space to play.');
</script>
</body>
</html>
